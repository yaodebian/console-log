# Vue Series

## 相比于 Vue2.0，Vue3.0 有那些变化？

我一般会从三个方面去讲：底层实现、开发体验、性能与扩展性。

**首先是 底层实现。**
Vue3 最大的变化就是响应式系统从 Object.defineProperty 换成了 Proxy。
这样可以直接监听对象的新增、删除、数组索引这些以前做不到的情况，性能也更好，代码量更少，整体更灵活。

**第二个是 开发体验。**
Vue3 引入了 Composition API，比如 setup、ref、reactive 这些。
它主要解决了 Vue2 里 mixin 逻辑分散、复用困难的问题，让我们可以更清晰地组织代码逻辑，也更好地配合 TypeScript 使用。

**然后是 性能和打包优化。**
Vue3 整个源码是基于 ES Module 写的，天然支持 Tree-shaking，打包时只会包含用到的部分，体积更小。
另外，它的虚拟 DOM 也做了重写，比如静态节点提升、diff 算法优化，渲染效率更高。

**再有一些新的特性也挺实用的，比如：**
- Fragment 支持多根节点组件，不用再多包一层 div；
- Teleport 可以把组件内容渲染到 DOM 任意位置，比如做弹窗；
- Suspense 用来更优雅地处理异步组件加载；
- 还有 自定义渲染器 API，可以让 Vue 渲染到非 DOM 环境，比如 Canvas 或终端。

总体来说，Vue3 不只是语法更新，它是一次架构级重写，在性能、类型支持和灵活性上都比 Vue2 提升非常大。

## 为什么 Vue 3 放弃 Object.defineProperty 改用 Proxy？

1. Object.defineProperty 只能监听已有属性，新增或删除属性时需要手动处理；
2. 对数组下标变化无法劫持；
3. 深层对象需要递归遍历所有属性，初始化成本高；
4. Proxy 可以懒代理（访问到子对象时再代理），性能更优；
5. Proxy 可以监听更多类型的操作，如删除属性、获取键名等。

**简答模板：**
因为 Proxy 功能更全面、性能更好，且能天然支持数组和深层对象，所以 Vue 3 用它替代了 Object.defineProperty。

## vue2默认通过defineProperty无法监听某些数组操作，这些操作有哪些，然后vue又是怎么解决的

数组操作包括：
- 下标赋值
- pop
- push
- shift
- unshift
- splice

默认 vue2 通过 defineProperty 是无法监听的，vue2 中的解法是：
- 全局Array类的原型拷贝一份
- 对这个备份原型的方法一一进行重写，里面会去触发响应式更新，并将一些新加的对象数据进行响应式处理，同时执行原始原型中的方法来确保数组被正常操作
- 备份原型会被挂载到原始对象上面，替换原始原型
- 这样，当用户调用数组方法时，会先触发我们重写的方法，里面会去触发响应式更新，然后再执行原始原型中的方法

## vue2 中 defineProperty 无法监听索引的新增和删除，最终 vue2 是如何处理的？

vue2 补充了两个方法来手动触发响应式更新：
- Vue.set(target, index, value)
- Vue.delete(target, index)

## vue中，我们需要在循环渲染中绑定一个唯一key，为什么？

使用 key 可以让 Vue 在进行 v-for 生成列表时准确识别每个节点。
这样可以保证在数据变化时，Diff 算法不会错误复用旧 DOM，从而避免组件状态错位、输入框内容错乱、动画错误等问题。同时能提升更新效率，实现最小化 DOM 操作。

## vue的响应式原理请简单描述下

- 初始化：vue在初始化时会基于 state 创建响应式对象。vue2 基于 defineProperty ，vue3 基于 proxy 。
- 模板编译：vue会把 template 编译成 render 函数。
- 生成 virtual dom ：基于 render 函数生成虚拟 DOM ，期间会基于 getter 监听模板中涉及的响应式属性，并收集为依赖。
- 渲染：将虚拟 DOM 渲染为真实的 DOM 。
- 触发更新渲染：针对之前收集为依赖的 state ，当它们发生变更时，会在 setter 中触发依赖的更新函数，从而实现响应式更新。

## 请简单聊聊你对虚拟 DOM 的理解

虚拟 DOM 是使用 JS 对 DOM 的抽象表示，它让框架能够在内存中完成计算和 diff，只把最小变更同步到真实 DOM，从而获得更高的更新效率和更好的可维护性。

## 请简述一下 Vue 的数据双向绑定

Vue的数据双向绑定，这里的双向是指 “数据变更触发视图渲染” 与 “视图变更触发数据变更”，它们分别是基于“Vue的响应式机制” 和 “事件触发” 来完成。这里说的 “事件触发” ，在 vue2 中是 input 事件，在vue3中是抛出 update:modelValue 来更新，这使得 Vue3 能够支持更多组件类型的数据双向绑定，同时 Vue3 也封装了一个 defineModel 的宏来方便你做这件事，同时也补充了一个 v-model 参数如 v-model:title 来自定义数据双向绑定的 props 。

## vue和react的区别

- 核心思想不同：
  - Vue属于渐进式框架，它开箱即用，同时可以增量式地使用功能。
  - React是函数式UI库，仅提供组件渲染和状态管理的基础能力，其余如路由、状态管理、构建工具等均依赖社区生态。该设计带来了高度的灵活性，同时也增加了技术选型与工程化的复杂度。
- 语法不同：
  - Vue 采用模板（Template）作为描述 UI 的主要方式。
  - React 使用 JSX，通过 JavaScript 来直接描述界面结构。
- 更新机制不同：
  - 在 Vue 中，更新机制是依赖响应式系统驱动的。Vue 会通过 defineProperty（Vue2）或 Proxy（Vue3）对数据访问进行拦截，收集依赖，并在数据变更时自动触发对应组件的更新，不需要开发者显式调用更新函数。
  - React 则不同，它不会自动追踪数据依赖。React 的更新必须通过 setState/useState 等方法显式触发，这会标记组件需要重新渲染，并在下一次 render 阶段重新执行组件函数，最终通过 diff 更新 DOM 节点。
- 通信模式不同：
  - Vue 在框架层面提供多种通信方案，包括 props/emit、provide/inject、以及官方状态管理工具 Pinia，能满足大多数组件通信场景。
  - React 的通信方式以 props 和 Context 为核心，更复杂的状态共享则依赖外部状态管理库（如 Redux、Zustand、MobX 等）。
- 生态体系不同：
  - Vue 的生态由官方高度统一，包括 Vue Router、Pinia、Vite、DevTools 等。官方生态耦合度高、风格统一，使得 Vue 项目从开发到构建都具备较强的一致性。
  - React 的生态主要来自社区，各类库在设计理念、使用方式上差异明显。例如路由可选 React Router，状态管理可选 Redux、Zustand、Jotai 等。生态十分丰富，但也带来选择成本，易出现团队内部技术栈不统一的问题。
- 性能表现差异：
  - Vue3 通过 Proxy、编译优化、以及精确的依赖追踪，使其默认情况下具有较优的渲染性能。在大部分场景中，Vue 组件的更新粒度更小，渲染路径更明确。
  - React 默认采用自顶向下的组件渲染策略，性能表现更依赖组件结构设计与手动优化。若缺少 memo 化等措施，可能会触发不必要的渲染。

## 请简单谈谈你对AST的理解

AST 本质上是“代码的语法结构树”。所有代码分析和代码转换工具——如 Babel、Webpack、ESLint、TS 编译器——都必须先把源码转成 AST 才能进行下一步工作。AST 让工具可以像理解数据结构一样理解你的代码，从而实现编译、优化、替换、检查等能力。
